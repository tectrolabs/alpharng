/**
 Copyright (C) 2014-2021 TectroLabs, https://tectrolabs.com

 THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
 INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

 This class may only be used in conjunction with TectroLabs devices.

 This class is used for interacting with the hardware random data generator device AlphaRNG for the purpose of
 downloading and distributing true random bytes using named pipes.

 It uses OpenSSL library.

 */

 /**
  *    @file EntropyServer.cpp
  *    @date 03/10/2021
  *    @Author: Andrian Belinski
  *    @version 1.0
  *
  *    @brief A pipe service for distributing true random bytes generated by an AlphaRNG device
  */

#include "EntropyServer.h"

namespace alpharng {

	
/**
* Constructor
*/
EntropyServer::EntropyServer(AlphaRngApi* rng, Cmd* cmd) {
	this->m_cmd = cmd;
	this->m_rng = rng;
}

/**
* @param idx - pipe instance index
*/
void EntropyServer::reconnect(DWORD idx)
{
	if (!DisconnectNamedPipe(m_pipe[idx].hPipeInst))
	{
		cerr << "DisconnectNamedPipe failed with " << GetLastError() << "." << endl;
	}

	m_pipe[idx].fPendingIO = connect_to_new_clinet(
		m_pipe[idx].hPipeInst,
		&m_pipe[idx].oOverlap);

	m_pipe[idx].dwState = m_pipe[idx].fPendingIO ?
		c_connectiong_state : // still connecting 
		c_reading_state;     // ready to read 
}

/*
* This function is called to start an overlapped connect operation.
* 
* @param hPipe pipe handle
* @param lpo overlapped flag
* @return TRUE if an operation is pending or FALSE if the
*/

BOOL EntropyServer::connect_to_new_clinet(HANDLE hPipe, LPOVERLAPPED lpo)
{
	BOOL fConnected, fPendingIO = FALSE;
	fConnected = ConnectNamedPipe(hPipe, lpo);
	if (fConnected)
	{
		cerr << "ConnectNamedPipe failed with " << GetLastError() << "." << endl;
		return 0;
	}

	switch (GetLastError())
	{
	case ERROR_IO_PENDING:
		fPendingIO = TRUE;
		break;
	case ERROR_PIPE_CONNECTED:
		if (SetEvent(lpo->hEvent))
			break;
	default:
	{
		cerr << "ConnectNamedPipe failed with " << GetLastError() << "." << endl;
		return 0;
	}
	}
	return fPendingIO;
}

/**
* Start and run the pipe service
*
* @return true when run successfully
*/
bool EntropyServer::run() {

	if (!m_rng->connect(m_cmd->device_number)) {
		cerr << m_rng->get_last_error() << endl;
		return false;
	}

	if (!m_cmd->pipe_name.empty()) {
		m_pipe_endpoint = wstring(m_cmd->pipe_name.begin(), m_cmd->pipe_name.end()).c_str();
	}
	else {
		m_pipe_endpoint = m_default_pipe_endpoint;
	}

	bool pipesStatus = create_pipe_instances();
	if (pipesStatus != true) {
		return pipesStatus;
	}

	string id;
	string model;
	unsigned char major_version;
	unsigned char minor_version;
	m_rng->retrieve_device_id(id);
	m_rng->retrieve_device_model(model);
	m_rng->retrieve_device_major_version(&major_version);
	m_rng->retrieve_device_minor_version(&minor_version);

	cout << "Entropy server started using device '" << model << "' with S/N: " << id << " and Ver: " << (int)major_version << "." << (int)minor_version << endl;

	while (1)
	{
		m_dw_wait = WaitForMultipleObjects(
			m_pipe_instances,    // number of event objects 
			m_handle_events,      // array of event objects 
			FALSE,        // does not wait for all 
			INFINITE);    // wait indefinitely 

		m_dw_idx = m_dw_wait - WAIT_OBJECT_0;
		if (m_dw_idx < 0 || m_dw_idx >(m_pipe_instances - 1))
		{
			cerr << "Index out of range." << endl;
			return false;
		}

		if (m_pipe[m_dw_idx].fPendingIO)
		{
			m_f_success = GetOverlappedResult(
				m_pipe[m_dw_idx].hPipeInst, // handle to pipe 
				&m_pipe[m_dw_idx].oOverlap, // OVERLAPPED structure 
				&m_dw_cb_ret,            // bytes transferred 
				FALSE);            // do not wait 

			switch (m_pipe[m_dw_idx].dwState)
			{
			case c_connectiong_state:
				if (!m_f_success)
				{
					cerr << "Error " << GetLastError() << " ." << endl;
					return false;
				}
				m_pipe[m_dw_idx].dwState = c_reading_state;
				break;

			case c_reading_state:
				if (!m_f_success || m_dw_cb_ret == 0)
				{
					reconnect(m_dw_idx);
					continue;
				}
				m_pipe[m_dw_idx].cbRead = m_dw_cb_ret;
				m_pipe[m_dw_idx].dwState = c_writing_state;
				break;

			case c_writing_state:
				if (!m_f_success || m_dw_cb_ret != m_pipe[m_dw_idx].chRequest.cbReqData)
				{
					reconnect(m_dw_idx);
					continue;
				}
				m_pipe[m_dw_idx].dwState = c_reading_state;
				break;

			default:
			{
				cerr << "Invalid pipe state." << endl;
				return false;
			}
			}
		}

		switch (m_pipe[m_dw_idx].dwState)
		{
		case c_reading_state:
			m_f_success = ReadFile(
				m_pipe[m_dw_idx].hPipeInst,
				&m_pipe[m_dw_idx].chRequest,
				sizeof(READCMD),
				&m_pipe[m_dw_idx].cbRead,
				&m_pipe[m_dw_idx].oOverlap);

			if (m_f_success && m_pipe[m_dw_idx].cbRead == sizeof(READCMD))
			{
				m_pipe[m_dw_idx].fPendingIO = FALSE;
				m_pipe[m_dw_idx].dwState = c_writing_state;
				continue;
			}
			m_dw_err = GetLastError();
			if (!m_f_success && (m_dw_err == ERROR_IO_PENDING))
			{
				m_pipe[m_dw_idx].fPendingIO = TRUE;
				continue;
			}
			reconnect(m_dw_idx);
			break;

		case c_writing_state:

			if (!fill_entropy_for_write(m_dw_idx)) {
				reconnect(m_dw_idx);
				break;
			}
			m_f_success = WriteFile(
				m_pipe[m_dw_idx].hPipeInst,
				m_pipe[m_dw_idx].chReply,
				m_pipe[m_dw_idx].chRequest.cbReqData,
				&m_dw_cb_ret,
				&m_pipe[m_dw_idx].oOverlap);

			if (m_f_success && m_dw_cb_ret == m_pipe[m_dw_idx].chRequest.cbReqData)
			{
				m_pipe[m_dw_idx].fPendingIO = FALSE;
				m_pipe[m_dw_idx].dwState = c_reading_state;
				continue;
			}

			m_dw_err = GetLastError();
			if (!m_f_success && (m_dw_err == ERROR_IO_PENDING))
			{
				m_pipe[m_dw_idx].fPendingIO = TRUE;
				continue;
			}
			reconnect(m_dw_idx);
			break;

		default:
		{
			cerr << "Invalid pipe state." << endl;
			return false;
		}
		}
	}

	return true;
}

/**
* Create a pool of named pipe instances
*
* @return true when run successfully
*/
bool EntropyServer::create_pipe_instances() {
	for (m_dw_idx = 0; m_dw_idx < m_pipe_instances; m_dw_idx++)
	{

		m_handle_events[m_dw_idx] = CreateEvent(
			NULL,
			TRUE,
			TRUE,
			NULL);

		if (m_handle_events[m_dw_idx] == NULL)
		{
			cerr << "CreateEvent failed with " << GetLastError() << " error code." << endl;
			return false;
		}

		m_pipe[m_dw_idx].oOverlap.hEvent = m_handle_events[m_dw_idx];

		m_pipe[m_dw_idx].hPipeInst = CreateNamedPipe(
			m_pipe_endpoint.c_str(),// pipe name 
			PIPE_ACCESS_DUPLEX |    // read/write access 
			FILE_FLAG_OVERLAPPED,   // overlapped mode 
			PIPE_TYPE_BYTE |		// byte-type pipe 
			PIPE_READMODE_BYTE |	// byte-read mode 
			PIPE_WAIT,              // blocking mode 
			m_pipe_instances,       // number of instances 
			c_write_buff_size_bytes,// output buffer size 
			sizeof(READCMD),		// input buffer size 
			c_pipe_timeout,         // client time-out 
			NULL);                  // default security attributes 

		if (m_pipe[m_dw_idx].hPipeInst == INVALID_HANDLE_VALUE)
		{
			cerr << "CreateNamedPipe failed with " << GetLastError() << " error code." << endl;
			return false;
		}

		m_pipe[m_dw_idx].fPendingIO = connect_to_new_clinet(
			m_pipe[m_dw_idx].hPipeInst,
			&m_pipe[m_dw_idx].oOverlap);

		m_pipe[m_dw_idx].dwState = m_pipe[m_dw_idx].fPendingIO ? c_connectiong_state : c_reading_state;
	}
	return true;
}

/**
* Populate the entropy buffer
*
* @param idx - pipe instance index
* @return true when run successfully
*/
bool EntropyServer::fill_entropy_for_write(DWORD idx) {
	bool devStatus = false;
	unsigned char testCounter = 0;
	if (m_pipe[idx].chRequest.cbReqData <= 0 || m_pipe[idx].chRequest.cbReqData > c_write_buff_size_bytes) {
		return devStatus;
	}
	switch (m_pipe[idx].chRequest.cmd) {
	case c_cmd_entropy_retrieve_id:
		devStatus = retrieve_entropy(idx);
		if (devStatus != true) {
			m_rng->disconnect();
			devStatus = m_rng->connect(m_cmd->device_number);
			if (devStatus == true) {
				devStatus = retrieve_entropy(idx);
			}
		}
		break;
	case c_cmd_diag_id:
		testCounter = 0;
		for (DWORD t = 0; t < m_pipe[idx].chRequest.cbReqData; t++) {
			m_pipe[idx].chReply[t] = testCounter++;
		}
		devStatus = true;
		break;
	default:
		cerr << "Invalid command received: " << m_pipe[idx].chRequest.cmd << endl;
		devStatus = false;
	}
	return devStatus;
}

/**
* Populate the entropy buffer
*
* @param idx - pipe instance index
* @return true when run successfully
*/
bool EntropyServer::retrieve_entropy(DWORD idx) {
	return m_rng->get_entropy(m_pipe[idx].chReply, m_pipe[idx].chRequest.cbReqData);
}

} /* namespace alpharng */